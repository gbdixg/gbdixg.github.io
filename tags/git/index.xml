<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>git on Write-Verbose</title>
    <link>https://write-verbose.com/tags/git/</link>
    <description>Recent content in git on Write-Verbose</description>
    <image>
      <title>Write-Verbose</title>
      <url>https://write-verbose.com/papermod-cover.png</url>
      <link>https://write-verbose.com/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 04 Jul 2021 14:27:50 +0000</lastBuildDate><atom:link href="https://write-verbose.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GIT edge cases</title>
      <link>https://write-verbose.com/2021/07/04/gitedgecases/</link>
      <pubDate>Sun, 04 Jul 2021 14:27:50 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/07/04/gitedgecases/</guid>
      <description>&lt;p&gt;Most of the time in GIT we are working at the file level.  It is possible to get more granualar and work with &lt;em&gt;hunks&lt;/em&gt; which are parts of a file e.g. a number of lines.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Most of the time in GIT we are working at the file level.  It is possible to get more granualar and work with <em>hunks</em> which are parts of a file e.g. a number of lines.</p>
<h2 id="using-hunks">Using Hunks</h2>
<p>The <code>--patch</code> option of the <code>git add</code> command causes GIT to automatically split an updated file into hunks.  It then prompts for each hunk and the contributor can decide whether to stage some or all of the hunks.<br>
GIT actually enters a menu system that allows granular control, such as splitting the hunk into smaller units. After adding some hunks but not all to the index, <code>git status</code> shows the same file is ready to be committed and also not yet staged for commit.</p>
<p>There are many commands that can work at the hunk level, including:</p>
<ul>
<li>git checkout</li>
<li>git stash</li>
<li>git reset</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt;git add --patch file.txt <span class="c1"># This command </span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>1/1<span class="o">)</span> Stage this hunk <span class="o">[</span>y,n,q,a,d,s,e,?<span class="o">]</span> ?
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">y - stage this hunk
</span></span><span class="line"><span class="cl">n - <span class="k">do</span> not stage this hunk
</span></span><span class="line"><span class="cl">q - quit
</span></span><span class="line"><span class="cl">a - stage this hunk
</span></span><span class="line"><span class="cl">d - <span class="k">do</span> not stage this hunk or an of the later hunks in the file
</span></span><span class="line"><span class="cl">s - split the current hunk into smaller hunks
</span></span><span class="line"><span class="cl">e - manually edit the current hunk
</span></span><span class="line"><span class="cl">? - print <span class="nb">help</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git status <span class="c1"># After adding some hunks but not all, the status shows the same file is ready to be committed and also not yet staged for commit</span>
</span></span><span class="line"><span class="cl">Changes to be committed:
</span></span><span class="line"><span class="cl">   modified:  file.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Changes not staged <span class="k">for</span> commit:
</span></span><span class="line"><span class="cl">   modified:   file.txt
</span></span></code></pre></div><h2 id="many-ways-to-reference-a-commit">Many ways to reference a commit</h2>
<p>The <code>git show</code> command provides information about a commit.  The most common way to reference a commit is using its hash (or partial hash), but there are also other ways:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git show 8d4112 <span class="c1">#  use the partial hash to refer to the commit</span>
</span></span><span class="line"><span class="cl">commit 8d411239358d55f45747c401c5c2c3fba8652d71
</span></span><span class="line"><span class="cl">Author: Geoff Dixon &lt;dixon@mail.home&gt;
</span></span><span class="line"><span class="cl">Date:   Mon Jun <span class="m">7</span> 17:44:03 +100
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">&gt; 
</span></span><span class="line"><span class="cl">&gt; git show HEAD <span class="c1"># show information about the latest commit</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git show HEAD^ <span class="c1"># show the parent commit of HEAD</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git show HEAD^^ <span class="c1"># show the second parent of HEAD</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git show HEAD~2 <span class="c1"># show the 2nd commit before HEAD (same as above)</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git show HEAD@<span class="o">{</span><span class="s2">&#34;1 week ago&#34;</span><span class="o">}</span> <span class="c1"># show head 1 week ago</span>
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
    <item>
      <title>GitHub - Contribute to a repo using Fork, Clone, Push and Pull Requests</title>
      <link>https://write-verbose.com/2021/06/30/github/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/30/github/</guid>
      <description>&lt;p&gt;GitHub hosts open source projects that have multiple contributors. Only a few maintainers have read-write access to the repository, so how do people contribute suggested changes?&lt;/p&gt;
&lt;p&gt;The answer is by copying the repo to their own GitHub account, making changes and submitting a &lt;em&gt;pull request&lt;/em&gt; to the maintainers of the original project. This post explains the steps.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>GitHub hosts open source projects that have multiple contributors. Only a few maintainers have read-write access to the repository, so how do people contribute suggested changes?</p>
<p>The answer is by copying the repo to their own GitHub account, making changes and submitting a <em>pull request</em> to the maintainers of the original project. This post explains the steps.</p>
<h2 id="contributing-on-github">CONTRIBUTING ON GitHub</h2>
<h3 id="forking-a-repo">Forking a repo</h3>
<p>A fork is a clone of the repo on the same hosting provider site (i.e. GitHub). You can view all the forks from the repo home page by clicking on <em>Insights &gt; Forks</em></p>
<p>As an example of how forks are used, the <a href="https://github.com/gohugoio/hugo">Hugo repository on GitHub</a> contains code for a static website generator.  The maintainers of the project have write access and can push changes, but other GitHub users have read access.</p>
<p>Any GitHub contributor can suggest changes by first forking the repo into their own GitHub account. The <em>Fork</em> button at the top-right of the  home page clones the Hugo repo to a copy that appears under the contributors GitHub account. The contributor now has write access to the forked copy, but it isn&rsquo;t that convenient to work directly on GitHub. They need to clone the fork to a GIT repo on their development workstation.</p>
<h3 id="cloning-a-fork">Cloning a fork</h3>
<p>The contributor clones the forked repo to a local GIT repo using <code>git clone &lt;SSH or HTTP address of fork repo&gt;</code>. By default, this clone will track a single remote repo called <em>origin</em> (the fork) that will aceept pushed updates. But how does the local repo keep track of the primary Hugo repo, and how are contributor changes pushed to the original source?</p>
<h3 id="adding-a-second-remote">Adding a second remote</h3>
<p>While the contributor is working on their local changes, the original Hugo repo on GitHub is also getting updates from other contributors. Any conflicts need to be resolved locally rather than expecting the maintainers of the repo to deal with them. So how does the contributor stay up-to-date while working locally on their changes?</p>
<p>The local workstation repo already has a remote (<em>origin</em>, the forked repo on GitHub). Adding the original Hugo repo as a second remote allows the local repo to pull chages from other contributors. This second remote is usually called <em>upstream</em>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git remote -v <span class="c1"># show current remote repos</span>
</span></span><span class="line"><span class="cl">origin  https://github.com/myaccount/myfork.git <span class="o">(</span>fetch<span class="o">)</span>
</span></span><span class="line"><span class="cl">origin  https://github.com/myaccount/myfork.git <span class="o">(</span>push<span class="o">)</span>
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git remote add upstream https://github.com/sourcerepo/sourceproject.git <span class="c1"># Add a second remote pointing to upstream</span>
</span></span></code></pre></div><h3 id="how-to-push-changes-to-upstream">How to push changes to upstream</h3>
<p>The final piece of the puzzle, is how to get the contributor&rsquo;s changes into the upstream repo without having write access.</p>
<p>GIT itself doesn&rsquo;t offer a solution to this, but GitHub does hence it&rsquo;s popularity for open source projects.<br>
First the contributor pushes their local repo changes to the GitHub fork (origin) using standard GIT commands. Next the contributor creates a <em>pull request</em> asking the maintainers of the <em>upstream</em> source repo to pull changes from the fork.  The pull request is a messaging system that describes the changes and enables differencing checks.</p>
<p>The maintainers of the upstream repo can review and comment on the changes, possibly asking for changes before pulling and merging them into the original repo.</p>
<h2 id="using-git-diff-and-blame">Using GIT Diff and Blame</h2>
<p>DIFF and BLAME are useful when reviewing a pull request or the project history.</p>
<p><code>git blame</code> shows the file history on a line-by-line basis.<br>
For each line, it displays the last commit where a line was changed, who made the change and when.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git blame .<span class="se">\i</span>ndex.md
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   1<span class="o">)</span> ---
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   2<span class="o">)</span> author: GD
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   3<span class="o">)</span> ---
</span></span><span class="line"><span class="cl">cc0e10d2 <span class="o">(</span>GD 2021-05-11 15:55:25 +0100   4<span class="o">)</span> **This is the first post in a series on creating a graph database CMDB.**
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   5<span class="o">)</span>
</span></span><span class="line"><span class="cl">7c78446d <span class="o">(</span>GD 2021-05-24 19:50:01 +0100   6<span class="o">)</span> Part 1: This article
</span></span><span class="line"><span class="cl">7c78446d <span class="o">(</span>GD 2021-06-24 21:03:19 +0100   7<span class="o">)</span> Part 2: How to <span class="nb">export</span> computer information from Microsoft Active Directory using PowerShell, <span class="k">for</span> use in a Neo4j CMDB
</span></span></code></pre></div><p><code>git diff</code> shows the differences between commits or between the git areas (working directory, index, repo). For example, to show the differene between the current commit and back two commits:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git diff HEAD HEAD~2 <span class="c1"># show the difference between the current position of HEAD and 2 commits before HEAD</span>
</span></span><span class="line"><span class="cl">diff --git a/content/blog/gitnotes/index.md b/content/blog/gitnotes/index.md
</span></span><span class="line"><span class="cl">index 10fa938..cc16e9f <span class="m">100644</span>
</span></span><span class="line"><span class="cl">--- a/content/blog/gitnotes/index.md  
</span></span><span class="line"><span class="cl">+++ b/content/blog/gitnotes/index.md
</span></span><span class="line"><span class="cl">@@ -14,48 +14,31 @@ 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-The version control system GIT can seem complex, but an understanding of the internal working can <span class="nb">help</span> with day-to-day use and is essential to get yourself out of an unexpected state. This article covers the basics of how git works, exploring the files in the object database and laying a foundation <span class="k">for</span> you to explore futher on your own.
</span></span><span class="line"><span class="cl">+An understanding of git internals helps with day-to-day use and is essential <span class="k">if</span> you need to get yourself out of an unexpected state. This article covers the basics of how git works, allowing you to explore further on your own.
</span></span></code></pre></div><p>The first line shows the diff command <code>diff --git...</code><br>
The next line is git metadata that isn&rsquo;t normally needed <code>index 10fa938..cc16e9f 100644</code><br>
The next two lines show assign symbols to the two versions of the index.md file i.e changes from HEAD are marked with &ldquo;&mdash;&rdquo; and tchanges from HEAD~2 are marked with &ldquo;+++&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">--- a/content/blog/gitnotes/index.md  
</span></span><span class="line"><span class="cl">+++ b/content/blog/gitnotes/index.md
</span></span></code></pre></div><p>The next line represents the header of a hunk (portion) of the file showing the lines that have been modified. In this case, 48 lines were removed at line 14 and 31 lines added at line 14. Realistically, when lines are removed and added at the same location it is a modification of the lines.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">@@ -14,48 +14,31 @@
</span></span></code></pre></div><p>Finally, the actual lines that are removed and added are displayed. The &ldquo;-&rdquo; at the start of the line means it was removed. The &ldquo;+&rdquo; at the start of the line means it was added. The line was actually edited to change some of the words.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">-The version control system GIT can seem complex...
</span></span><span class="line"><span class="cl">+An understanding of git internals helps...
</span></span></code></pre></div><p>Another way to view the differences is using the <code>--color-words</code> option. This shows the changes in-line using red for removed and green for added i.e.</p>
<p><code>git diff --color-words HEAD HEAD~2</code></p>
<h3 id="what-else-can-you-compare-with-git-diff">What else can you compare with GIT DIFF?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git diff <span class="c1"># show uncommited changes since the last commit</span>
</span></span><span class="line"><span class="cl">&gt; 
</span></span><span class="line"><span class="cl">&gt; git diff --cached <span class="c1"># compare the repo HEAD to the index</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git diff feature1 main <span class="c1"># compare two branches</span>
</span></span></code></pre></div><h3 id="how-to-see-a-diff-of-every-commit">How to see a diff of every commit</h3>
<p>The <code>git log</code> command has an option to diff every commit. This obviously produces a lot of output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git log --patch
</span></span></code></pre></div><h3 id="how-to-compare-the-list-of-commits-between-two-branches">How to compare the list of commits between two branches</h3>
<p>Rather than looking at the changes in the commits. You will sometimes want to just look at the history of commits and understand which are only in one branch compared to another. <code>git log</code> can also help here:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git log feature1..main --oneline <span class="c1"># Compare the feature1 branch to main showing the commits only in main</span>
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
    <item>
      <title>GIT branches - merging, rebasing and squashing commits</title>
      <link>https://write-verbose.com/2021/06/27/usinggit/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/27/usinggit/</guid>
      <description>&lt;p&gt;This article focuses on common GIT actions that affect branches, such as merging, rebasing branches and squashing local commits.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>This article focuses on common GIT actions that affect branches, such as merging, rebasing branches and squashing local commits.</p>
<h2 id="merge">MERGE</h2>
<p>Merging brings changes from one branch into another. A feature branch is often created to work on a particular update. When complete, the branch needs to be merged back into &ldquo;main&rdquo;. The process would be as follows:</p>
<p>First switch to the main branch using either <code>git switch main</code> or <code>git checkout main</code>.<br>
Next merge the featureA branch into main using <code>git merge featureA</code>.</p>
<p>GIT will create a new commit with the merged changes. This is a special commit as it has two parents - the previous commit on main and the previous commit on the featureA branch. The main branch is updated to point to this new commit and HEAD continues to point to main. FeatureA still points to the last commit on that branch.</p>
<h2 id="conflicts">CONFLICTS</h2>
<p>If a conflict is detected during a merge, GIT will interupt the process and prompt for user action<br>
GIT will be in a special state where it expects the conflict to be resolved before continuing.<br>
<code>git status</code> at this point shows the message &ldquo;you have unmerged paths&hellip;fix conflicts and run <code>git commit</code>&hellip;use <code>git merge --abort</code> to abort the merge&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">You have unmerged paths.
</span></span><span class="line"><span class="cl">  <span class="o">(</span>fix conflicts and run <span class="s2">&#34;git commit&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Unmerged paths:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to mark resolution<span class="o">)</span>
</span></span><span class="line"><span class="cl">        both modified:   consolidate.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>GIT will display the files that have conflicts.  The problem can be resolved at the command line, but a graphical diff tool such as <a href="https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge">p4merge</a> may be better.</p>
<p>If you open the files in a basic text editor you will see GIT has marked the conflicts.<br>
In the example below, the file &ldquo;consolidate.py&rdquo; is in conflict. GIT has updated the file with markers showing the lines that need attendtion. The HEAD section shows the lines as they appear in the current branch (main).  Then there is a section break and directly below are the same lines as they appear in the <em>featureA</em> branch.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">import sys
</span></span><span class="line"><span class="cl"><span class="o">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
</span></span><span class="line"><span class="cl"><span class="nv">name</span><span class="o">=</span><span class="nb">read</span> <span class="s2">&#34;Enter your name&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">age</span><span class="o">=</span><span class="nb">read</span> <span class="s2">&#34;Enter your age&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">=======</span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> <span class="s2">&#34;Please enter your name&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> <span class="s2">&#34;Enter your age&#34;</span>
</span></span><span class="line"><span class="cl">&gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA
</span></span></code></pre></div><p>To resolve the conflict, manually edit the file so it reflects the desired state and remove the markers and section break.<br>
Save the file,  add it to the GIT index, then commit the change to complete the merge, as shown below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git add consolidate.py
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git commit
</span></span><span class="line"><span class="cl"><span class="o">[</span>main 1aca0e1<span class="o">]</span> Introduce featureA that enables user input
</span></span></code></pre></div><p>In summary:</p>
<ol>
<li>Switch to the branch you are merging into (e.g. <code>git switch main</code>)</li>
<li>Merge the required branch into the current branch (i.e. <code>git merge feature1</code>)</li>
<li>Fix any conflict by editing the file</li>
<li>Add the updated file to the index (<code>git add &lt;file&gt;</code>)</li>
<li>Commit to complete the merge (<code>git commit</code>)</li>
</ol>
<h2 id="fast-forward-merge">FAST FORWARD MERGE</h2>
<p>A fast forward merge occurs automatically when git moves a branch without having to create a new commit. It just re-uses an existing commit.<br>
The most common case is when you want to merge a feature branch into main, but then continue working on the Feature branch with the latest updates from main.<br>
When you first merge the branch into main, GIT creates a new commit on main that has two parents - the previous commit on main and the previous commit on the branch.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch main
</span></span><span class="line"><span class="cl">❯ git merge featureA
</span></span></code></pre></div><p>The status is now:</p>
<ul>
<li>main branch: contains the latest changes and any conflict resolutions</li>
<li>featureA branch: contains the working feature before the merge into main</li>
</ul>
<p>To continue developing on featureA, you need to merge main back into the featureA branch so it has the latest updates</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch featureA
</span></span><span class="line"><span class="cl">❯ git merge main
</span></span></code></pre></div><p>At this point, GIT realises that there is already a commit that has the merged contents of featureA and main, so it just re-uses this commit.  The merge message shows it performed a &ldquo;fast-forward merge&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git merge main
</span></span><span class="line"><span class="cl">Updating 68a874e..1aca0e1
</span></span><span class="line"><span class="cl">Fast-forward
</span></span><span class="line"><span class="cl"> consolidate.py <span class="p">|</span> <span class="m">6</span> +++---
</span></span><span class="line"><span class="cl"> orders.py      <span class="p">|</span> <span class="m">4</span> ++++
</span></span><span class="line"><span class="cl"> <span class="m">2</span> files changed, <span class="m">7</span> insertions<span class="o">(</span>+<span class="o">)</span>, <span class="m">3</span> deletions<span class="o">(</span>-<span class="o">)</span>
</span></span></code></pre></div><h2 id="detached-head">DETACHED HEAD</h2>
<p>HEAD is a reference to a branch or a commit. Normally HEAD points to the current branch and thereby indirectly to the latest commit on that branch.  <em>Detached head</em> is a state where the HEAD is not referencing a branch, it is pointing to an older commit.</p>
<p>Why would this happen?  Perhaps you want to do some experimentation without creating a branch.  You would checkout a commit rather than creating a branch.  At this point HEAD is no longer tracking a branch and so it is detached. It acts like a temporary branch. After making some commits, you could do one of the following:</p>
<p>a) Switch back to a branch<br>
b) Put a branch on the current commit</p>
<p>If you switch back to a branch, any previous commits outside a branch are isolated in the object database and are not referenced by any branch. Eventually they will be removed by the GIT garbage collector.</p>
<p>Alternatively, <code>git branch &lt;branchname&gt;</code> can be used to put a branch on the current commit. At this point it is like any other branch and HEAD is no longer detached.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git checkout 460ce0e
</span></span><span class="line"><span class="cl">Note: switching to <span class="s1">&#39;460ce0e&#39;</span>.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">You are in <span class="s1">&#39;detached HEAD&#39;</span> state. You can look around, make experimental
</span></span><span class="line"><span class="cl">changes and commit them, and you can discard any commits you make in this
</span></span><span class="line"><span class="cl">state without impacting any branches by switching back to a branch.
</span></span></code></pre></div><h2 id="rebase">REBASE</h2>
<p>Rebase is an alternative to a merge.  It changes the base of a branch, effectively adding it to the top of another branch as if the changes were sequential rather than created in parallel.</p>
<p>The rebase process looks at the first commit that is shared by two branches and uses the next commit as the base of the branch being rebased.  It detaches this branch and re-attaches it to the head of the other branch. Under the hood, the commits do not actually move, new commits are created that are copies of the original commits on the branch. GIT moves the branch and the original commits become orphaned and eventually garbage collected.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git switch featureA <span class="c1"># make featureA the current branch</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git rebase main <span class="c1"># rebase the featureA branch onto main</span>
</span></span></code></pre></div><h3 id="why-use-rebase">Why use Rebase?</h3>
<p>Rebase can help to simplify the history of a project. If there is a lot of merging it can complicate the history.<br>
Howver, use with caution. Rebased history is not the true history, so merging is safer.</p>
<h3 id="squashing-commits">Squashing commits</h3>
<p><em>Squashing</em> re-writes the GIT history, making two or more commits appear as if they were a single commit. Why would you want to do this?  Developers often commit very frequently when working locally on a feature, but don&rsquo;t want to complicate the shared history with all these individual commits.  Squashing commits before merging or pushing to an origin repo simplifies the history in a large project.</p>
<p>The interactive mode of <code>git rebase</code> is used to squash commits. This is totally different to the basic use of rebase. A starting point commit must be specified as we don&rsquo;t normally want to edit the entire history. The starting point is excluded from the list and the interactive mode starts from the next commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git rebase --interactive 80f137
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pick fd4d8d9 Updates Adsense css
</span></span><span class="line"><span class="cl">pick 8d41123 Adds adsense css
</span></span><span class="line"><span class="cl">pick 9b2aafa Adds article
</span></span><span class="line"><span class="cl">pick 32735fb Fixes error in  post
</span></span><span class="line"><span class="cl">pick 7f0063a Fixes typo
</span></span><span class="line"><span class="cl">pick c85a17f Adds article
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Rebase 55a0831..c85a17f onto 55a0831 (6 commands)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Commands:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># p, pick &lt;commit&gt; = use commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span class="line"><span class="cl"><span class="c1"># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span class="line"><span class="cl"><span class="c1"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message</span>
</span></span><span class="line"><span class="cl"><span class="c1"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span class="line"><span class="cl"><span class="c1"># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span class="line"><span class="cl"><span class="c1"># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span class="line"><span class="cl"><span class="c1"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       message (or the oneline, if no original merge commit was</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># These lines can be re-ordered; they are executed from top to bottom.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># However, if you remove everything, the rebase will be aborted.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span></code></pre></div><p>An interactive editor opens as shown above.  The commits are listed (in reverse order compared to most git commands). The editor gives the commands - such as pick, reword etc.</p>
<p>By default all commits are on a line that starts with &ldquo;pick&rdquo;. Editing these lines will modify the history.<br>
For example, you can move entire lines to change the order of commits.
Changing &ldquo;pick&rdquo; to &ldquo;squash&rdquo;  will cause the commit to be merged with the one above and GIT will prompt to select or edit one of the two commit messages.</p>
<h3 id="the-golden-rule-of-rebase">The golden rule of Rebase</h3>
<p>Rebasing can lead to problems when sharing a repo across a team. The purpose of the rebase is to simplify history, but it can lead to duplication in the GIT multi-master sharing model.  The golden rule is therefore:</p>
<blockquote>
<p>Never rebase shared commits. Only use rebase for commits that have not yet been shared.</p>
</blockquote>
<h2 id="ammending-a-commit">Ammending a commit</h2>
<p>If you want to update the latest commit to add additional files, add them to the index then use the <code>--ammend</code> option on <code>git commit</code>. This will create a new commit with the additional files and leave the previous commit as an orphan that will eventually get garbage collected. You can only use this option to update the latest commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git commit --ammend 
</span></span></code></pre></div><h2 id="tags">TAGS</h2>
<p>Tags are labels for a commit. Tags are normally used to mark releases.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git tag version1_0 -a -m <span class="s2">&#34;First version. Basic features&#34;</span> <span class="c1"># Create a new annotated tag</span>
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git tag version2_0 <span class="c1"># Create a lightweight tag (not annotated)</span>
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git tag <span class="c1"># get a list of tags</span>
</span></span></code></pre></div><p>Tags are rederences to a commit, but unlike branches, tags never move.</p>
<h2 id="clone">CLONE</h2>
<p><code>git clone</code> is used to copy an existing repository into an empty local folder. The copy contains the working files and the full GIT history.<br>
The existing repo can be local or remote. It can be referenced by an SSH or HTTP address. By default, it will clone the branch HEAD is pointing to, but this can be modified using the <code>-branch</code> option.</p>
<p>The command is mostly used to clone a repo from a hosting service such as Github - so it can be edited locally and then pushed back up to Github.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git clone https://github.com/myaccount/myrepo <span class="c1"># clone a repo from Github into the current local folder</span>
</span></span></code></pre></div><p>The source repo is registered as a &ldquo;remote&rdquo; called <em>origin</em> by default. <code>git status</code> will show if the local branch is ahead or behind the remote branch.</p>
<p>The information about the remote repo is stored in the /git/config file. The remote branches are tracked by objects in the <em>.git/refs/remotes folder</em>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git show-ref main <span class="c1"># show all branches that have main in the name and the commit they are pointing to</span>
</span></span><span class="line"><span class="cl">8195805D refs/heads/main
</span></span><span class="line"><span class="cl">B05DB506 refs/remotes/origin/main
</span></span></code></pre></div><p>If the local repo is in-sync with the remote, they will be pointing to the same commit, i.e. the hashes above would be the same.</p>
<p>The <code>git clone -bare</code> option will clone the history but not the working area. It will also not setup the original source as a remote. This  can be used to create a central repo that is just a source for cloning and not worked on directly.</p>
<h2 id="push--fetch--pull">PUSH / FETCH / PULL</h2>
<p><code>git push</code> is used to send local changes to the remote origin repo.  But what happens if there have been other changes on the remote before we push and we now have a conflict?</p>
<p>The answer is to fetch the remote changes and resolve the conflict locally before pushing. There is a comand to get the latest changes from the remote - <code>git fetch</code>, but rather than fetching and then merging in two steps, the <code>git pull</code> command peforms a fetch and merge in one command.</p>
<p>When working with a remote, you should always pull before pushing.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git pull origin
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
    <item>
      <title>GIT storage - understanding the stash, working, index, repo</title>
      <link>https://write-verbose.com/2021/06/24/gitandthefourareas/</link>
      <pubDate>Thu, 24 Jun 2021 17:45:34 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/24/gitandthefourareas/</guid>
      <description>&lt;p&gt;GIT commands move data between four areas of the object database. This article explores the four areas and the common commands that affect them.&lt;/p&gt;
&lt;p&gt;See the earlier post on &lt;a href=&#34;https://write-verbose.com/2021/06/17/git-cheatnotes/&#34;&gt;How GIT stores information&lt;/a&gt; for information on the GIT object database.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>GIT commands move data between four areas of the object database. This article explores the four areas and the common commands that affect them.</p>
<p>See the earlier post on <a href="/2021/06/17/git-cheatnotes/">How GIT stores information</a> for information on the GIT object database.</p>
<h2 id="what-are-the-four-areas-git-uses">What are the four areas GIT uses?</h2>
<ol>
<li>The <em>Working Area</em> stores project source files updated directly by a code editor</li>
<li>The <em>Index</em> (or Staging Areas) tracks which files from the working area included in the next commit</li>
<li>The <em>Repository</em> (or Repo) is the most important area, where GIT stores snapshots of the tracked files, called <em>commits</em></li>
<li>The <em>Stash</em> is a temporary area, a bit like a clipboard, that can store and retrieve a saved copy of the working area and index</li>
</ol>
<p>Understanding git requires understanding how commands move data between these four areas.</p>
<p><img loading="lazy" src="/img/gitnotes-git1.jpg" alt="FourAreas"  />
</p>
<h2 id="git-status">GIT STATUS</h2>
<p><code>git status</code> is one of the most important commands. It shows the status of the working area and index. The most common output shows untracked files and modified files.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">nothing to commit, working tree clean
</span></span></code></pre></div><h3 id="new-files">New files</h3>
<p>When a file is created or copied into the project, it only exists in the working area. <code>git status</code> will show the file as <em>untracked</em>. It has not been added to the index (staging) area and will not be part of the next commit until added. The status command shows the list of new files and suggests how to add them to the index.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Untracked files:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to include in what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">        consolidate.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nothing added to commit but untracked files present <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> to track<span class="o">)</span>
</span></span></code></pre></div><h3 id="modified-files">Modified files</h3>
<p>Files added to the index are tracked by GIT. When a tracked file is updated or modified, <code>git status</code> shows the it as <em>modified</em> and not yet staged for commit. The working area version has changed, but GIT is only tracking the previous version in the index. The updated file needs to be added to the index to be included in the next commit. The status command shows the modified files and suggests actions to take.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Changes not staged <span class="k">for</span> commit:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to update what will be committed<span class="o">)</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git restore &lt;file&gt;...&#34;</span> to discard changes in working directory<span class="o">)</span>
</span></span><span class="line"><span class="cl">        modified:   consolidate.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</span></span></code></pre></div><h3 id="changes-not-committed">Changes not committed</h3>
<p><code>git status</code> also shows changes in the index but not yet committed to the repo. These could be new and/or modified files.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Changes to be committed:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git restore --staged &lt;file&gt;...&#34;</span> to unstage<span class="o">)</span>
</span></span><span class="line"><span class="cl">        modified:   consolidate.py
</span></span></code></pre></div><h3 id="remote">Remote</h3>
<p>A <em>remote</em> is a linked repository, for example, a central source repo that the local repo was originally cloned from. GIT maintains the link to the remote and tracks differences. By default, the remote is named <em>origin</em>. <code>git status</code> will show if the remote repo is ahead or behind the current local commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">Your branch is ahead of <span class="s1">&#39;origin/master&#39;</span> by <span class="m">1</span> commit.
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git push&#34;</span> to publish your <span class="nb">local</span> commits<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">nothing to commit, working tree clean
</span></span></code></pre></div><h2 id="git-add">GIT ADD</h2>
<p>The <code>git add</code> command updates the index (staging) area to track new files or add new versions of already tracked files.  The most common parameters are as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git add mynewfile.txt <span class="c1"># stage a specific file in the index</span>
</span></span><span class="line"><span class="cl">❯ git add folder1/ <span class="c1"># stage all new and modified files in folder1</span>
</span></span><span class="line"><span class="cl">❯ git add -A <span class="c1"># stage all new and modified files in the entire project</span>
</span></span><span class="line"><span class="cl">❯ git add . <span class="c1"># same as above</span>
</span></span><span class="line"><span class="cl">❯ git add -i <span class="c1"># interactive mode. Prompts for a decision on a file-by-file basis</span>
</span></span></code></pre></div><h2 id="git-diff">GIT DIFF</h2>
<p><code>git diff</code> shows differences between the GIT areas, such as between the working area and index, or between the index and repo. Differences are displayed at the command line. <code>git diff</code> is convenient for quick checks and small changes. Graphical tools may be better suited for complex comparisons.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git diff <span class="c1"># shows differences between the working area and index</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git diff --cached <span class="c1"># shows differences between the index and repo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">diff --git a/consolidate.py b/consolidate.py
</span></span><span class="line"><span class="cl">index de10111..97f66ce <span class="m">100644</span>
</span></span><span class="line"><span class="cl">--- a/consolidate.py
</span></span><span class="line"><span class="cl">+++ b/consolidate.py
</span></span><span class="line"><span class="cl">@@ -1 +1,2 @@
</span></span><span class="line"><span class="cl"> import sys
</span></span><span class="line"><span class="cl">+print <span class="o">(</span>sys.version<span class="o">)</span>
</span></span></code></pre></div><p>In the example output above, there is a difference between the index and the repo. A line has been added in the index version, indicated by the &ldquo;+&rdquo; symbol.</p>
<h2 id="git-commit">GIT COMMIT</h2>
<p>The <code>git commit</code> command creates a point-in-time snapshot of tracked files in the repo. New and modified files from the index are added to the repo as new objects. Unchanged files are just referenced by a link to the existing object in the repo. The commit itself is an object in the repository, pointing to a tree and any parent commit.<br>
A commit is named using a SHA1 hash. It can be referenced in commands using just the first few characters of the hash (enough that it is not ambiguous).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git commit -m <span class="s2">&#34;Enabled handling of user input&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>main b9b6064<span class="o">]</span> Enabled handling of user input
</span></span><span class="line"><span class="cl"> <span class="m">1</span> file changed, <span class="m">1</span> insertion<span class="o">(</span>+<span class="o">)</span>, <span class="m">1</span> deletion<span class="o">(</span>-<span class="o">)</span>
</span></span></code></pre></div><p>In the output above, a new commit is created on the main branch with partial SHA1 hash <em>b9b6064</em></p>
<h2 id="git-branch">GIT BRANCH</h2>
<p>A branch is just a reference to a commit. Creating a branch does not actually change objects in the repo, it just creates a named pointer to an existing commit.
If you are on the <em>main</em> branch and create a new branch called <em>dev</em>, GIT adds a new <em>dev</em> object in the .git/refs folder pointing to the current commit. Initially both branches are pointing to the same commit.<br>
The <code>git branch</code> command shows the current branches or creates a new branch, but does not switch to it. The asterisk in the output below shows that after creating a new <em>dev</em> branch, main is still the current branch:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git branch dev <span class="c1"># create a new branch. </span>
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git branch <span class="c1"># show branches</span>
</span></span><span class="line"><span class="cl">  dev
</span></span><span class="line"><span class="cl">* main
</span></span></code></pre></div><h2 id="git-switch">GIT SWITCH</h2>
<p><code>git switch</code> is a relatively new command that switches between branches. It does not make changes to the repo, but it does affect the working area and index. When you switch to another branch, the GIT <em>HEAD</em> reference is updated to point to the selected branch. The branch refers to a commit and the files and folders in the working area and index are replaced by the files in this commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch dev
</span></span><span class="line"><span class="cl">Switched to branch <span class="s1">&#39;dev&#39;</span>
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git branch
</span></span><span class="line"><span class="cl">* dev
</span></span><span class="line"><span class="cl">  main
</span></span></code></pre></div><p>You can create a branch and switch to it with the <code>-c</code> option</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch -c feature
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature&#39;</span>
</span></span></code></pre></div><h2 id="git-checkout">GIT CHECKOUT</h2>
<p>When it comes to moving between branches, <code>git checkout</code> is almost identical to <code>git switch</code>. The checkout command has been around for much longer and has options that perform other actions. The variety of uses for the checkout command was deemed confusing and switch was introduced to focus purely on moving between branches.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git checkout dev <span class="c1"># change to the dev branch</span>
</span></span><span class="line"><span class="cl">Switched to branch <span class="s1">&#39;dev&#39;</span>
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git branch <span class="c1"># show &#39;dev&#39; is now the current branch</span>
</span></span><span class="line"><span class="cl">* dev
</span></span><span class="line"><span class="cl">  feature
</span></span><span class="line"><span class="cl">  main
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git checkout -b feature2 <span class="c1"># create a new branch and switch to it</span>
</span></span><span class="line"><span class="cl">Switched to a new branch <span class="s1">&#39;feature2&#39;</span>
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git branch <span class="c1"># show &#39;feature2&#39; is not the current branch</span>
</span></span><span class="line"><span class="cl">  dev
</span></span><span class="line"><span class="cl">  feature
</span></span><span class="line"><span class="cl">* feature2
</span></span><span class="line"><span class="cl">  main
</span></span></code></pre></div><h2 id="git-log">GIT LOG</h2>
<p><code>git log</code> shows the history of commits and branches. It does not make any changes to the repo, index or working area. Use the &ndash;graph option to see a basic diagram of branches and merges:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git log --oneline --graph --decorate
</span></span><span class="line"><span class="cl">*   a7d531d <span class="o">(</span>HEAD -&gt; main<span class="o">)</span> Merge Feature2, resolve conflict in orders.py
</span></span><span class="line"><span class="cl"><span class="p">|</span><span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span><span class="p">|</span> * d0773eb <span class="o">(</span>feature2<span class="o">)</span> Adds input validation to orders.py
</span></span><span class="line"><span class="cl">* <span class="p">|</span> bba3001 Modifies output in orders.py
</span></span><span class="line"><span class="cl"><span class="p">|</span>/
</span></span><span class="line"><span class="cl">* 460ce0e Enables user input
</span></span><span class="line"><span class="cl">* b9b6064 Creates orders.py
</span></span></code></pre></div><h2 id="git-reset">GIT RESET</h2>
<p><code>git reset</code> is used to rollback to a previous commit. It can affect the repo, the index and the working area depending on the parameters.<br>
A common use case is to abandon some changes that have been committed and revert to a previous version of the project. Another is to abandon changes in the working area and revert to the last commit in the repo.</p>
<p>The reset command will move the current branch to the specified commit. By default, it will also overwrite the index with the contents of the commit. If you want to completely remove all traces of the unwanted change, you can also overwrite the working area using the &ndash;hard option</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git log --oneline <span class="c1"># show the history of commits</span>
</span></span><span class="line"><span class="cl">848eae0 <span class="o">(</span>HEAD -&gt; main<span class="o">)</span> Adds search to <span class="m">404</span> page
</span></span><span class="line"><span class="cl">364b33f Changes format of <span class="m">404</span> page
</span></span><span class="line"><span class="cl">d4ff0dc Modifies position of search box 
</span></span><span class="line"><span class="cl">c55dbb1 Enables comments
</span></span><span class="line"><span class="cl">cccb986 Adds home page, header and footer
</span></span><span class="line"><span class="cl"><span class="m">4478398</span> Initial commit
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git reset --hard d4ff0dc  <span class="c1"># Rollback the repo two commits, overwriting the index and working area</span>
</span></span><span class="line"><span class="cl">HEAD is now at d4ff0dc Modifies position of search box
</span></span></code></pre></div><p>Other options are:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git reset --mixed d4ff0dc <span class="c1"># Rollback the repo two commits but only overwrite the index. The working area is not touched. This is also the default if no options are specified.</span>
</span></span><span class="line"><span class="cl">&gt; git reset --soft d4ff0dc <span class="c1"># Rollback the repo two commits, but don&#39;t touch the index or working area</span>
</span></span></code></pre></div><h3 id="head-reset">HEAD RESET</h3>
<p><code>git reset HEAD</code> is a quick way to return the index/working area to the committed state of the repo. This is an unsual reset as it doesn&rsquo;t actually change anything in the repo.</p>
<p>HEAD is usually poiting to the latest commit on the current branch.  Resetting the repo to HEAD changes nothing in the repo, but by default it will perform a <em>mixed</em> reset, overwriting the index.  We can also use the &ndash;hard option to overwrite both the index and working area:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git reset --hard HEAD
</span></span></code></pre></div><h2 id="git-stash">GIT STASH</h2>
<p>The Stash is a temporary storage area to save the working area and index when you need to working on another feature. You don&rsquo;t want to lose or commit what you are currently working on, so you stash the changes, work on something else and then retrieve them later.  Its a bit like saving something in a clipboard.</p>
<p>When you run <code>git stash</code>, GIT copies tracked files in the working area and index that aren&rsquo;t in the current commit and saves them to the stash. It then checks out the current commit (overwriting the working area and index so they match the repo).</p>
<p>When ready to restore the stashed files, run <code>git stash apply</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git stash --include-untracked  <span class="c1"># Save changes to the stash including untracked files</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git stash list <span class="c1"># List the contents of the stash. This is an array of saves starting with zero</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git stash apply <span class="c1"># Copies the latest entry in the stash to the working area and index. You can also specify an array element number if you don&#39;t want the latest</span>
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
    <item>
      <title>GIT basics - under-the-hood</title>
      <link>https://write-verbose.com/2021/06/17/git-cheatnotes/</link>
      <pubDate>Thu, 17 Jun 2021 20:11:34 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/17/git-cheatnotes/</guid>
      <description>&lt;p&gt;GIT has become the de-facto version control system, but it can get complicated quickly. A look under-the-hood can help with day-to-day use and file recovery. This article explores the files in the object database laying a foundation for more advanced use.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>GIT has become the de-facto version control system, but it can get complicated quickly. A look under-the-hood can help with day-to-day use and file recovery. This article explores the files in the object database laying a foundation for more advanced use.</p>
<h2 id="how-does-git-store-objects">HOW DOES GIT STORE OBJECTS?</h2>
<p>GIT stores information in the hidden <code>.git</code> folder in the root of the project. The folder is created when a repository is initialized using <code>git init</code></p>
<blockquote>
<p>Commits, trees and blobs are the fundamental objects in GIT</p>
</blockquote>
<p>They are stored in the .git/objects folder:</p>
<ul>
<li>Commits are a point in time reference to a tree</li>
<li>Trees represent folders</li>
<li>Blobs represent files*</li>
</ul>
<p>*Blobs can also represent &ldquo;hunks&rdquo; (chunks of a file), but thats a more advanced topic for another article</p>
<h2 id="whats-with-all-the-sha1-hashes">WHAT&rsquo;S WITH ALL THE SHA1 HASHES?</h2>
<p>GIT creates a SHA1 checksum for each object and stores them in files under the.git/objects folder. The files are named after the SHA1 hash which means objects in the database are immutable - they cannot change. Modified files always result in new objects with a new hash, rather than updating the existing.</p>
<p>GIT uses the hash values to determine which files have been modfied during a commit. New and modified files are added as new blobs. Unchanged files are just referenced, keeping the existing blob.</p>
<p>To avoid storing everything in one folder, git creates subfolders under .git/objects. The subfolder folder names are the first two characters of the SHA1 hash and the objects are grouped in these subfolders. The filename in the subfolder is the remaining characters of the hash.<br>
For example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ ls .git/objects
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">00</span>
</span></span><span class="line"><span class="cl">00/24a57c6cee77755693e0514f244b1cfa5e645d
</span></span><span class="line"><span class="cl">00/5b63f2cf1d596fa3f88834b98272a9d1bf9fc3
</span></span><span class="line"><span class="cl">00/f823e0b5420e1051c80e0b37922409125e9156
</span></span><span class="line"><span class="cl"><span class="m">01</span>
</span></span><span class="line"><span class="cl">01/28a8cb2ac88861ec18599c0b05f9481bdd3600
</span></span><span class="line"><span class="cl">01/8c65d03d8269df96a7da4c3de1a62cd1d1c0ab
</span></span><span class="line"><span class="cl"><span class="m">02</span>
</span></span><span class="line"><span class="cl">02/188f346460de1876df7dac2669360396f84a58
</span></span></code></pre></div><p>In the above example, there are three subfolders under .git/objects, called &ldquo;00&rdquo;, &ldquo;01&rdquo; and &ldquo;02&rdquo;.
The full SHA1 hash of an object is constructed by adding the parent folder name to the filename.<br>
So the final file listed above has the full hash of <span style="color:lightgreen">02</span>188f346460de1876df7dac2669360396f84a58</p>
<h2 id="can-you-look-inside-the-objects">CAN YOU LOOK INSIDE THE OBJECTS?</h2>
<p>The objects inside the git database are compressed, but can be viewed with the command <code>git cat-file</code><br>
Specify the object hash and either:<br>
-t = show the object type<br>
-p = print the contents</p>
<p>NOTE: You only need part of the hash when using most GIT commands (and GIT sometimes truncates the hash in its own output)</p>
<h3 id="what-type-of-object-is-this">WHAT TYPE OF OBJECT IS THIS?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git cat-file 0b4271c56 -t <span class="c1"># display the object type</span>
</span></span><span class="line"><span class="cl">commit
</span></span></code></pre></div><p>The above object is a commit.</p>
<h3 id="whats-inside-a-commit-object">WHAT&rsquo;S INSIDE A COMMIT OBJECT?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git cat-file 0b4271c56 -p
</span></span><span class="line"><span class="cl">tree 30b4d42bbe1a39dcc314f7c280b1437a1925585e
</span></span><span class="line"><span class="cl">parent cc0e10d238e78a57115572360a93deba2554d185
</span></span><span class="line"><span class="cl">author GD &lt;GD@LOCAL.HOME&gt; <span class="m">1621179226</span> +0100
</span></span><span class="line"><span class="cl">committer GD &lt;GD@LOCAL.HOME&gt; <span class="m">1621179226</span> +0100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Updated summaries. Added article
</span></span></code></pre></div><p>In the above output:</p>
<ul>
<li><em>tree</em>  is a hash reference to the root tree (folder).</li>
<li><em>parent</em> is the hash of the parent commit (unless this is the first commit)</li>
<li><em>Author</em> and <em>committer</em> are the operator who created the commit</li>
<li>Finally there is the commit message, <em>Updated summaries&hellip;</em></li>
</ul>
<h3 id="whats-in-a-tree-object">WHAT&rsquo;S IN A TREE OBJECT?</h3>
<p>We can view the contents of a tree object in the same way e.g. using the hash of the tree in the commit above:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git cat-file -p 30b4d42bbe
</span></span><span class="line"><span class="cl"><span class="m">100644</span> blob d298be107f27247a24d24f8f78c55d42359007be    .gitignore
</span></span><span class="line"><span class="cl"><span class="m">100644</span> blob e3720ce5ced245ef02620afca619727c001e85bf    404.html
</span></span><span class="line"><span class="cl"><span class="m">100644</span> blob 82b909c8a3de119782d6b66288734f82a4a57d1b    about.md
</span></span><span class="line"><span class="cl"><span class="m">040000</span> tree 272bc4b082fa15dd84b08712206d2edfe2b41e9a    archetypes
</span></span><span class="line"><span class="cl"><span class="m">040000</span> tree e305983083fc1872542004d046abdf3a683407e1    config
</span></span><span class="line"><span class="cl"><span class="m">040000</span> tree 955f968be02f980640e570874f4c155da51882d4    content
</span></span></code></pre></div><p>The first three items in the output are references to blobs (files) in the root of the tree (e.g. the <em>.gitignore</em> file). The rest are references to child trees, which can be explored further using the cat-file command.</p>
<h3 id="whats-in-a-blob">WHAT&rsquo;S IN A BLOB?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git cat-file -t d298be107 <span class="c1"># get the object type</span>
</span></span><span class="line"><span class="cl">blob
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git cat-file -p d298be107 <span class="c1"># get the object contents</span>
</span></span><span class="line"><span class="cl">public/
</span></span></code></pre></div><p>The blob finally contains the actual content, rather than a reference.<br>
In this case, it is the .gitignore file that contains a single line to exclude <em>public</em> from the repo</p>
<h3 id="what-about-branches">WHAT ABOUT BRANCHES?</h3>
<p>Branches are very simple in GIT. They are just references to a commit.</p>
<p>Branch objects aren&rsquo;t compressed so we can look at the contents of the file directly (without needing git cat-file).<br>
Local branches are stored in the .git/refs/heads folder:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ cat .git/refs/heads/main  <span class="c1"># show the contents of the main file</span>
</span></span><span class="line"><span class="cl">0b4271c561e6c7ad5dcf788afdc29bebbf11e171
</span></span></code></pre></div><p>This output is what we expected, the contents of the main branch are a reference to a commit using the SHA1 hash.</p>
<p>If we explore the branch using git cat-file, it gives us information about the commit the branch is pointing to:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git cat-file -t main <span class="c1"># show the object type</span>
</span></span><span class="line"><span class="cl">commit
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git cat-file -p main <span class="c1"># show the object contents</span>
</span></span><span class="line"><span class="cl">tree 30b4d42bbe1a39dcc314f7c280b1437a1925585e
</span></span><span class="line"><span class="cl">parent cc0e10d238e78a57115572360a93deba2554d185
</span></span><span class="line"><span class="cl">author Geoff Dixon &lt;GBDixg@WESTCLIFF.HOME&gt; <span class="m">1621179226</span> +0100
</span></span><span class="line"><span class="cl">committer Geoff Dixon &lt;GBDixg@WESTCLIFF.HOME&gt; <span class="m">1621179226</span> +0100
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Updated summaries. Added article
</span></span></code></pre></div><p>This is identical to the contents of the commit we looked at earlier, because that was the latest commit on the main branch.</p>
<h3 id="whats-the-head">WHAT&rsquo;S THE HEAD?</h3>
<p>Head is a special pointer in GIT.  It is a reference to the commit that is currently checked-out. Usually the latest commit on the current branch, but not always.</p>
<p>The contents of HEAD is not a hash. It contains a pointer to the name of a branch or commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ cat .git/HEAD <span class="c1"># show contents of the HEAD file</span>
</span></span><span class="line"><span class="cl">ref: refs/heads/main
</span></span></code></pre></div><h2 id="summary">SUMMARY</h2>
<p>The git object database is all about references.</p>
<ul>
<li>HEAD is a reference to the current commit</li>
<li>A branch is a reference to a commit</li>
<li>A commit is a reference to a tree</li>
<li>A tree is a reference to blobs and child trees</li>
<li>A blob is the actual content</li>
</ul>
<p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
  </channel>
</rss>
