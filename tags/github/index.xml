<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>github on Write-Verbose</title>
    <link>https://write-verbose.com/tags/github/</link>
    <description>Recent content in github on Write-Verbose</description>
    <image>
      <title>Write-Verbose</title>
      <url>https://write-verbose.com/papermod-cover.png</url>
      <link>https://write-verbose.com/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 30 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://write-verbose.com/tags/github/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GitHub - Contribute to a repo using Fork, Clone, Push and Pull Requests</title>
      <link>https://write-verbose.com/2021/06/30/github/</link>
      <pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/30/github/</guid>
      <description>GitHub - Using Fork, Clone, Push and Pull Requests</description>
      <content:encoded><![CDATA[<p>GitHub hosts open source projects that have multiple contributors. Only a few maintainers have read-write access to the repository, so how do people contribute suggested changes?</p>
<p>The answer is by copying the repo to their own GitHub account, making changes and submitting a <em>pull request</em> to the maintainers of the original project. This post explains the steps.</p>
<h2 id="contributing-on-github">CONTRIBUTING ON GitHub</h2>
<h3 id="forking-a-repo">Forking a repo</h3>
<p>A fork is a clone of the repo on the same hosting provider site (i.e. GitHub). You can view all the forks from the repo home page by clicking on <em>Insights &gt; Forks</em></p>
<p>As an example of how forks are used, the <a href="https://github.com/gohugoio/hugo">Hugo repository on GitHub</a> contains code for a static website generator.  The maintainers of the project have write access and can push changes, but other GitHub users have read access.</p>
<p>Any GitHub contributor can suggest changes by first forking the repo into their own GitHub account. The <em>Fork</em> button at the top-right of the  home page clones the Hugo repo to a copy that appears under the contributors GitHub account. The contributor now has write access to the forked copy, but it isn&rsquo;t that convenient to work directly on GitHub. They need to clone the fork to a GIT repo on their development workstation.</p>
<h3 id="cloning-a-fork">Cloning a fork</h3>
<p>The contributor clones the forked repo to a local GIT repo using <code>git clone &lt;SSH or HTTP address of fork repo&gt;</code>. By default, this clone will track a single remote repo called <em>origin</em> (the fork) that will aceept pushed updates. But how does the local repo keep track of the primary Hugo repo, and how are contributor changes pushed to the original source?</p>
<h3 id="adding-a-second-remote">Adding a second remote</h3>
<p>While the contributor is working on their local changes, the original Hugo repo on GitHub is also getting updates from other contributors. Any conflicts need to be resolved locally rather than expecting the maintainers of the repo to deal with them. So how does the contributor stay up-to-date while working locally on their changes?</p>
<p>The local workstation repo already has a remote (<em>origin</em>, the forked repo on GitHub). Adding the original Hugo repo as a second remote allows the local repo to pull chages from other contributors. This second remote is usually called <em>upstream</em>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git remote -v <span class="c1"># show current remote repos</span>
</span></span><span class="line"><span class="cl">origin  https://github.com/myaccount/myfork.git <span class="o">(</span>fetch<span class="o">)</span>
</span></span><span class="line"><span class="cl">origin  https://github.com/myaccount/myfork.git <span class="o">(</span>push<span class="o">)</span>
</span></span><span class="line"><span class="cl">❯
</span></span><span class="line"><span class="cl">❯ git remote add upstream https://github.com/sourcerepo/sourceproject.git <span class="c1"># Add a second remote pointing to upstream</span>
</span></span></code></pre></div><h3 id="how-to-push-changes-to-upstream">How to push changes to upstream</h3>
<p>The final piece of the puzzle, is how to get the contributor&rsquo;s changes into the upstream repo without having write access.</p>
<p>GIT itself doesn&rsquo;t offer a solution to this, but GitHub does hence it&rsquo;s popularity for open source projects.<br>
First the contributor pushes their local repo changes to the GitHub fork (origin) using standard GIT commands. Next the contributor creates a <em>pull request</em> asking the maintainers of the <em>upstream</em> source repo to pull changes from the fork.  The pull request is a messaging system that describes the changes and enables differencing checks.</p>
<p>The maintainers of the upstream repo can review and comment on the changes, possibly asking for changes before pulling and merging them into the original repo.</p>
<h2 id="using-git-diff-and-blame">Using GIT Diff and Blame</h2>
<p>DIFF and BLAME are useful when reviewing a pull request or the project history.</p>
<p><code>git blame</code> shows the file history on a line-by-line basis.<br>
For each line, it displays the last commit where a line was changed, who made the change and when.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git blame .<span class="se">\i</span>ndex.md
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   1<span class="o">)</span> ---
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   2<span class="o">)</span> author: GD
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   3<span class="o">)</span> ---
</span></span><span class="line"><span class="cl">cc0e10d2 <span class="o">(</span>GD 2021-05-11 15:55:25 +0100   4<span class="o">)</span> **This is the first post in a series on creating a graph database CMDB.**
</span></span><span class="line"><span class="cl">cf6ff2bb <span class="o">(</span>GD 2021-05-05 22:09:05 +0100   5<span class="o">)</span>
</span></span><span class="line"><span class="cl">7c78446d <span class="o">(</span>GD 2021-05-24 19:50:01 +0100   6<span class="o">)</span> Part 1: This article
</span></span><span class="line"><span class="cl">7c78446d <span class="o">(</span>GD 2021-06-24 21:03:19 +0100   7<span class="o">)</span> Part 2: How to <span class="nb">export</span> computer information from Microsoft Active Directory using PowerShell, <span class="k">for</span> use in a Neo4j CMDB
</span></span></code></pre></div><p><code>git diff</code> shows the differences between commits or between the git areas (working directory, index, repo). For example, to show the differene between the current commit and back two commits:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git diff HEAD HEAD~2 <span class="c1"># show the difference between the current position of HEAD and 2 commits before HEAD</span>
</span></span><span class="line"><span class="cl">diff --git a/content/blog/gitnotes/index.md b/content/blog/gitnotes/index.md
</span></span><span class="line"><span class="cl">index 10fa938..cc16e9f <span class="m">100644</span>
</span></span><span class="line"><span class="cl">--- a/content/blog/gitnotes/index.md  
</span></span><span class="line"><span class="cl">+++ b/content/blog/gitnotes/index.md
</span></span><span class="line"><span class="cl">@@ -14,48 +14,31 @@ 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-The version control system GIT can seem complex, but an understanding of the internal working can <span class="nb">help</span> with day-to-day use and is essential to get yourself out of an unexpected state. This article covers the basics of how git works, exploring the files in the object database and laying a foundation <span class="k">for</span> you to explore futher on your own.
</span></span><span class="line"><span class="cl">+An understanding of git internals helps with day-to-day use and is essential <span class="k">if</span> you need to get yourself out of an unexpected state. This article covers the basics of how git works, allowing you to explore further on your own.
</span></span></code></pre></div><p>The first line shows the diff command <code>diff --git...</code><br>
The next line is git metadata that isn&rsquo;t normally needed <code>index 10fa938..cc16e9f 100644</code><br>
The next two lines show assign symbols to the two versions of the index.md file i.e changes from HEAD are marked with &ldquo;&mdash;&rdquo; and tchanges from HEAD~2 are marked with &ldquo;+++&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">--- a/content/blog/gitnotes/index.md  
</span></span><span class="line"><span class="cl">+++ b/content/blog/gitnotes/index.md
</span></span></code></pre></div><p>The next line represents the header of a hunk (portion) of the file showing the lines that have been modified. In this case, 48 lines were removed at line 14 and 31 lines added at line 14. Realistically, when lines are removed and added at the same location it is a modification of the lines.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">@@ -14,48 +14,31 @@
</span></span></code></pre></div><p>Finally, the actual lines that are removed and added are displayed. The &ldquo;-&rdquo; at the start of the line means it was removed. The &ldquo;+&rdquo; at the start of the line means it was added. The line was actually edited to change some of the words.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">-The version control system GIT can seem complex...
</span></span><span class="line"><span class="cl">+An understanding of git internals helps...
</span></span></code></pre></div><p>Another way to view the differences is using the <code>--color-words</code> option. This shows the changes in-line using red for removed and green for added i.e.</p>
<p><code>git diff --color-words HEAD HEAD~2</code></p>
<h3 id="what-else-can-you-compare-with-git-diff">What else can you compare with GIT DIFF?</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git diff <span class="c1"># show uncommited changes since the last commit</span>
</span></span><span class="line"><span class="cl">&gt; 
</span></span><span class="line"><span class="cl">&gt; git diff --cached <span class="c1"># compare the repo HEAD to the index</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git diff feature1 main <span class="c1"># compare two branches</span>
</span></span></code></pre></div><h3 id="how-to-see-a-diff-of-every-commit">How to see a diff of every commit</h3>
<p>The <code>git log</code> command has an option to diff every commit. This obviously produces a lot of output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git log --patch
</span></span></code></pre></div><h3 id="how-to-compare-the-list-of-commits-between-two-branches">How to compare the list of commits between two branches</h3>
<p>Rather than looking at the changes in the commits. You will sometimes want to just look at the history of commits and understand which are only in one branch compared to another. <code>git log</code> can also help here:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git log feature1..main --oneline <span class="c1"># Compare the feature1 branch to main showing the commits only in main</span>
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
    <item>
      <title>GIT branches - merging, rebasing and squashing commits</title>
      <link>https://write-verbose.com/2021/06/27/usinggit/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://write-verbose.com/2021/06/27/usinggit/</guid>
      <description>GIT commands that affect branches and history, focussing on merge, squashing commits and rebasing.</description>
      <content:encoded><![CDATA[<p>This article focuses on common GIT actions that affect branches, such as merging, rebasing branches and squashing local commits.</p>
<h2 id="merge">MERGE</h2>
<p>Merging brings changes from one branch into another. A feature branch is often created to work on a particular update. When complete, the branch needs to be merged back into &ldquo;main&rdquo;. The process would be as follows:</p>
<p>First switch to the main branch using either <code>git switch main</code> or <code>git checkout main</code>.<br>
Next merge the featureA branch into main using <code>git merge featureA</code>.</p>
<p>GIT will create a new commit with the merged changes. This is a special commit as it has two parents - the previous commit on main and the previous commit on the featureA branch. The main branch is updated to point to this new commit and HEAD continues to point to main. FeatureA still points to the last commit on that branch.</p>
<h2 id="conflicts">CONFLICTS</h2>
<p>If a conflict is detected during a merge, GIT will interupt the process and prompt for user action<br>
GIT will be in a special state where it expects the conflict to be resolved before continuing.<br>
<code>git status</code> at this point shows the message &ldquo;you have unmerged paths&hellip;fix conflicts and run <code>git commit</code>&hellip;use <code>git merge --abort</code> to abort the merge&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git status
</span></span><span class="line"><span class="cl">On branch master
</span></span><span class="line"><span class="cl">You have unmerged paths.
</span></span><span class="line"><span class="cl">  <span class="o">(</span>fix conflicts and run <span class="s2">&#34;git commit&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Unmerged paths:
</span></span><span class="line"><span class="cl">  <span class="o">(</span>use <span class="s2">&#34;git add &lt;file&gt;...&#34;</span> to mark resolution<span class="o">)</span>
</span></span><span class="line"><span class="cl">        both modified:   consolidate.py
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">no changes added to commit <span class="o">(</span>use <span class="s2">&#34;git add&#34;</span> and/or <span class="s2">&#34;git commit -a&#34;</span><span class="o">)</span>
</span></span></code></pre></div><p>GIT will display the files that have conflicts.  The problem can be resolved at the command line, but a graphical diff tool such as <a href="https://www.perforce.com/products/helix-core-apps/merge-diff-tool-p4merge">p4merge</a> may be better.</p>
<p>If you open the files in a basic text editor you will see GIT has marked the conflicts.<br>
In the example below, the file &ldquo;consolidate.py&rdquo; is in conflict. GIT has updated the file with markers showing the lines that need attendtion. The HEAD section shows the lines as they appear in the current branch (main).  Then there is a section break and directly below are the same lines as they appear in the <em>featureA</em> branch.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">import sys
</span></span><span class="line"><span class="cl"><span class="o">&lt;&lt;&lt;&lt;&lt;&lt;</span>&lt; HEAD
</span></span><span class="line"><span class="cl"><span class="nv">name</span><span class="o">=</span><span class="nb">read</span> <span class="s2">&#34;Enter your name&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nv">age</span><span class="o">=</span><span class="nb">read</span> <span class="s2">&#34;Enter your age&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">=======</span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> <span class="s2">&#34;Please enter your name&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nb">read</span> <span class="s2">&#34;Enter your age&#34;</span>
</span></span><span class="line"><span class="cl">&gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA
</span></span></code></pre></div><p>To resolve the conflict, manually edit the file so it reflects the desired state and remove the markers and section break.<br>
Save the file,  add it to the GIT index, then commit the change to complete the merge, as shown below:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git add consolidate.py
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git commit
</span></span><span class="line"><span class="cl"><span class="o">[</span>main 1aca0e1<span class="o">]</span> Introduce featureA that enables user input
</span></span></code></pre></div><p>In summary:</p>
<ol>
<li>Switch to the branch you are merging into (e.g. <code>git switch main</code>)</li>
<li>Merge the required branch into the current branch (i.e. <code>git merge feature1</code>)</li>
<li>Fix any conflict by editing the file</li>
<li>Add the updated file to the index (<code>git add &lt;file&gt;</code>)</li>
<li>Commit to complete the merge (<code>git commit</code>)</li>
</ol>
<h2 id="fast-forward-merge">FAST FORWARD MERGE</h2>
<p>A fast forward merge occurs automatically when git moves a branch without having to create a new commit. It just re-uses an existing commit.<br>
The most common case is when you want to merge a feature branch into main, but then continue working on the Feature branch with the latest updates from main.<br>
When you first merge the branch into main, GIT creates a new commit on main that has two parents - the previous commit on main and the previous commit on the branch.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch main
</span></span><span class="line"><span class="cl">❯ git merge featureA
</span></span></code></pre></div><p>The status is now:</p>
<ul>
<li>main branch: contains the latest changes and any conflict resolutions</li>
<li>featureA branch: contains the working feature before the merge into main</li>
</ul>
<p>To continue developing on featureA, you need to merge main back into the featureA branch so it has the latest updates</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git switch featureA
</span></span><span class="line"><span class="cl">❯ git merge main
</span></span></code></pre></div><p>At this point, GIT realises that there is already a commit that has the merged contents of featureA and main, so it just re-uses this commit.  The merge message shows it performed a &ldquo;fast-forward merge&rdquo;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git merge main
</span></span><span class="line"><span class="cl">Updating 68a874e..1aca0e1
</span></span><span class="line"><span class="cl">Fast-forward
</span></span><span class="line"><span class="cl"> consolidate.py <span class="p">|</span> <span class="m">6</span> +++---
</span></span><span class="line"><span class="cl"> orders.py      <span class="p">|</span> <span class="m">4</span> ++++
</span></span><span class="line"><span class="cl"> <span class="m">2</span> files changed, <span class="m">7</span> insertions<span class="o">(</span>+<span class="o">)</span>, <span class="m">3</span> deletions<span class="o">(</span>-<span class="o">)</span>
</span></span></code></pre></div><h2 id="detached-head">DETACHED HEAD</h2>
<p>HEAD is a reference to a branch or a commit. Normally HEAD points to the current branch and thereby indirectly to the latest commit on that branch.  <em>Detached head</em> is a state where the HEAD is not referencing a branch, it is pointing to an older commit.</p>
<p>Why would this happen?  Perhaps you want to do some experimentation without creating a branch.  You would checkout a commit rather than creating a branch.  At this point HEAD is no longer tracking a branch and so it is detached. It acts like a temporary branch. After making some commits, you could do one of the following:</p>
<p>a) Switch back to a branch<br>
b) Put a branch on the current commit</p>
<p>If you switch back to a branch, any previous commits outside a branch are isolated in the object database and are not referenced by any branch. Eventually they will be removed by the GIT garbage collector.</p>
<p>Alternatively, <code>git branch &lt;branchname&gt;</code> can be used to put a branch on the current commit. At this point it is like any other branch and HEAD is no longer detached.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git checkout 460ce0e
</span></span><span class="line"><span class="cl">Note: switching to <span class="s1">&#39;460ce0e&#39;</span>.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">You are in <span class="s1">&#39;detached HEAD&#39;</span> state. You can look around, make experimental
</span></span><span class="line"><span class="cl">changes and commit them, and you can discard any commits you make in this
</span></span><span class="line"><span class="cl">state without impacting any branches by switching back to a branch.
</span></span></code></pre></div><h2 id="rebase">REBASE</h2>
<p>Rebase is an alternative to a merge.  It changes the base of a branch, effectively adding it to the top of another branch as if the changes were sequential rather than created in parallel.</p>
<p>The rebase process looks at the first commit that is shared by two branches and uses the next commit as the base of the branch being rebased.  It detaches this branch and re-attaches it to the head of the other branch. Under the hood, the commits do not actually move, new commits are created that are copies of the original commits on the branch. GIT moves the branch and the original commits become orphaned and eventually garbage collected.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git switch featureA <span class="c1"># make featureA the current branch</span>
</span></span><span class="line"><span class="cl">&gt;
</span></span><span class="line"><span class="cl">&gt; git rebase main <span class="c1"># rebase the featureA branch onto main</span>
</span></span></code></pre></div><h3 id="why-use-rebase">Why use Rebase?</h3>
<p>Rebase can help to simplify the history of a project. If there is a lot of merging it can complicate the history.<br>
Howver, use with caution. Rebased history is not the true history, so merging is safer.</p>
<h3 id="squashing-commits">Squashing commits</h3>
<p><em>Squashing</em> re-writes the GIT history, making two or more commits appear as if they were a single commit. Why would you want to do this?  Developers often commit very frequently when working locally on a feature, but don&rsquo;t want to complicate the shared history with all these individual commits.  Squashing commits before merging or pushing to an origin repo simplifies the history in a large project.</p>
<p>The interactive mode of <code>git rebase</code> is used to squash commits. This is totally different to the basic use of rebase. A starting point commit must be specified as we don&rsquo;t normally want to edit the entire history. The starting point is excluded from the list and the interactive mode starts from the next commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git rebase --interactive 80f137
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">pick fd4d8d9 Updates Adsense css
</span></span><span class="line"><span class="cl">pick 8d41123 Adds adsense css
</span></span><span class="line"><span class="cl">pick 9b2aafa Adds article
</span></span><span class="line"><span class="cl">pick 32735fb Fixes error in  post
</span></span><span class="line"><span class="cl">pick 7f0063a Fixes typo
</span></span><span class="line"><span class="cl">pick c85a17f Adds article
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Rebase 55a0831..c85a17f onto 55a0831 (6 commands)</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Commands:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># p, pick &lt;commit&gt; = use commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span>
</span></span><span class="line"><span class="cl"><span class="c1"># e, edit &lt;commit&gt; = use commit, but stop for amending</span>
</span></span><span class="line"><span class="cl"><span class="c1"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># f, fixup &lt;commit&gt; = like &#34;squash&#34;, but discard this commit&#39;s log message</span>
</span></span><span class="line"><span class="cl"><span class="c1"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span>
</span></span><span class="line"><span class="cl"><span class="c1"># b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># d, drop &lt;commit&gt; = remove commit</span>
</span></span><span class="line"><span class="cl"><span class="c1"># l, label &lt;label&gt; = label current HEAD with a name</span>
</span></span><span class="line"><span class="cl"><span class="c1"># t, reset &lt;label&gt; = reset HEAD to a label</span>
</span></span><span class="line"><span class="cl"><span class="c1"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       create a merge commit using the original merge commit&#39;s</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       message (or the oneline, if no original merge commit was</span>
</span></span><span class="line"><span class="cl"><span class="c1"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># These lines can be re-ordered; they are executed from top to bottom.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># If you remove a line here THAT COMMIT WILL BE LOST.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="cl"><span class="c1"># However, if you remove everything, the rebase will be aborted.</span>
</span></span><span class="line"><span class="cl"><span class="c1">#</span>
</span></span></code></pre></div><p>An interactive editor opens as shown above.  The commits are listed (in reverse order compared to most git commands). The editor gives the commands - such as pick, reword etc.</p>
<p>By default all commits are on a line that starts with &ldquo;pick&rdquo;. Editing these lines will modify the history.<br>
For example, you can move entire lines to change the order of commits.
Changing &ldquo;pick&rdquo; to &ldquo;squash&rdquo;  will cause the commit to be merged with the one above and GIT will prompt to select or edit one of the two commit messages.</p>
<h3 id="the-golden-rule-of-rebase">The golden rule of Rebase</h3>
<p>Rebasing can lead to problems when sharing a repo across a team. The purpose of the rebase is to simplify history, but it can lead to duplication in the GIT multi-master sharing model.  The golden rule is therefore:</p>
<blockquote>
<p>Never rebase shared commits. Only use rebase for commits that have not yet been shared.</p>
</blockquote>
<h2 id="ammending-a-commit">Ammending a commit</h2>
<p>If you want to update the latest commit to add additional files, add them to the index then use the <code>--ammend</code> option on <code>git commit</code>. This will create a new commit with the additional files and leave the previous commit as an orphan that will eventually get garbage collected. You can only use this option to update the latest commit.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">&gt; git commit --ammend 
</span></span></code></pre></div><h2 id="tags">TAGS</h2>
<p>Tags are labels for a commit. Tags are normally used to mark releases.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git tag version1_0 -a -m <span class="s2">&#34;First version. Basic features&#34;</span> <span class="c1"># Create a new annotated tag</span>
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git tag version2_0 <span class="c1"># Create a lightweight tag (not annotated)</span>
</span></span><span class="line"><span class="cl">❯ 
</span></span><span class="line"><span class="cl">❯ git tag <span class="c1"># get a list of tags</span>
</span></span></code></pre></div><p>Tags are rederences to a commit, but unlike branches, tags never move.</p>
<h2 id="clone">CLONE</h2>
<p><code>git clone</code> is used to copy an existing repository into an empty local folder. The copy contains the working files and the full GIT history.<br>
The existing repo can be local or remote. It can be referenced by an SSH or HTTP address. By default, it will clone the branch HEAD is pointing to, but this can be modified using the <code>-branch</code> option.</p>
<p>The command is mostly used to clone a repo from a hosting service such as Github - so it can be edited locally and then pushed back up to Github.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git clone https://github.com/myaccount/myrepo <span class="c1"># clone a repo from Github into the current local folder</span>
</span></span></code></pre></div><p>The source repo is registered as a &ldquo;remote&rdquo; called <em>origin</em> by default. <code>git status</code> will show if the local branch is ahead or behind the remote branch.</p>
<p>The information about the remote repo is stored in the /git/config file. The remote branches are tracked by objects in the <em>.git/refs/remotes folder</em>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git show-ref main <span class="c1"># show all branches that have main in the name and the commit they are pointing to</span>
</span></span><span class="line"><span class="cl">8195805D refs/heads/main
</span></span><span class="line"><span class="cl">B05DB506 refs/remotes/origin/main
</span></span></code></pre></div><p>If the local repo is in-sync with the remote, they will be pointing to the same commit, i.e. the hashes above would be the same.</p>
<p>The <code>git clone -bare</code> option will clone the history but not the working area. It will also not setup the original source as a remote. This  can be used to create a central repo that is just a source for cloning and not worked on directly.</p>
<h2 id="push--fetch--pull">PUSH / FETCH / PULL</h2>
<p><code>git push</code> is used to send local changes to the remote origin repo.  But what happens if there have been other changes on the remote before we push and we now have a conflict?</p>
<p>The answer is to fetch the remote changes and resolve the conflict locally before pushing. There is a comand to get the latest changes from the remote - <code>git fetch</code>, but rather than fetching and then merging in two steps, the <code>git pull</code> command peforms a fetch and merge in one command.</p>
<p>When working with a remote, you should always pull before pushing.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">❯ git pull origin
</span></span></code></pre></div><p><br/><br/></p>
<blockquote>
<p>This article was originally posted on <a href="http://write-verbose.com">Write-Verbose.com</a></p>
</blockquote>]]></content:encoded>
    </item>
    
  </channel>
</rss>
